import re
from typing import Tuple

def parse_output(raw_output: str) -> Tuple[str, str]:
    """
    Parses the raw output from ask_model() to extract answer and explanation.
   
    Args:
        raw_output (str): The raw text output generated by the model.
       
    Returns:
        Tuple[answer: str, explanation: str]: A tuple containing the answer and explanation.
    """
    try:
        # Use regex to find the answer and explanation in the raw output
       raw_answer = re.search(r'Answer:\s*([A-D])', raw_output)
       raw_explanation = re.search(r'Explanation:\s*(.+)', raw_output, re.IGNORECASE | re.DOTALL)
       
       answer = raw_answer.group(1).upper()
       explanation = raw_explanation.group(1).strip()

       return (answer, explanation)

    except Exception as e:
        print(f"Error parsing output: {e}")
        return ("Parsing error", "Exception during parsing.")
    
PROMPT_TEMPLATE = (
    """Wybierz poprawną odpowiedź spośród A, B, C i D. Uzasdnij krótko swój wybór.\n
    Podaj wynik w formacie: \n
    Answer: [A/B/C/D]\n
    Explanation: [Twoja krótka odpowiedź]\n
    Pytanie: {question}\n
    A: {A}\n
    B: {B}\n
    C: {C}\n
    D: {D}\n
    """
)
    
def build_prompt(row) -> str:
    """Builds a prompt for the model from a DataFrame row.
        
    Args:
        row (pd.Series): A row from the DataFrame with columns 'Pytanie', 'A', 'B', 'C', 'D'.
            
    Returns:
       str: Formatted prompt string.
    """
    return PROMPT_TEMPLATE.format(
         question=row['Pytanie'],
         A=row['A'],
         B=row['B'],
         C=row['C'],
        D=row['D']                                                                       
    )